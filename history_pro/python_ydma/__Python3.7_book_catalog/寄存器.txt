变量相关
	什么是变量
		变量就是可以改变的量，如：
		x + y = 10
		x = 5    y = ?
		x = 7    y = ?
		上面示例中的 x 和 y 就是变量，它们是数学里的变量。
		通俗的理解：
			变量       =  生活中的容器(盒子)
			变量赋值操作 = 我们把物品放入盒子
			数据类型    =  放了不同物体的盒子(放了鞋子，那这个盒子的类型就是鞋盒；放了饭，就是饭盒...)
	变量赋值
		变量的命名规范：
			1.变量名支持中文 但不推荐使用
			2.可以使用数字 但不能以数字开头
			3.不可以使用特殊字符 除了下划线_
			4.变量严格区分大小写
			5.变量命名要有意义(规范)
			6.变量命名要避免和系统使用的保留关键字冲突
		变量赋值的基本格式
			变量名 = 值          如：age = 18
			变量的其他赋值方式
				变量1 = 变量2 = 变量3 = 值        （给多个变量同时赋同一个值）
				变量1，变量2，变量3 = 值1，值2，值3 （给多个变量同时分别赋不同的值）
			变量交换
				变量1,变量2 = 变量2，变量1
	变量的三个常用操作
		1.获取值    可直接通过变量名获取
			用法：name
		2.查看数据类型    使用type()函数
			用法：type(name)
		3.获取变量在内存中的id标识    使用id()函数
			用法：id(name)
	Python中，一切都是对象，包括变量，每个变量都是一个对象，对象的概念详见面向对象一文
	
	
关键字相关
	概念
		关键字就是一些具有特殊功能的标识符。在这里关键字指的是系统已经使用了的标识符，那么系统一般是不允许我们使用跟这些关键字同名的标识符的。
	查看系统保留关键字的方法：
		在命令行输入 import keyword 回车后输入 print(keyword.kwlist) 即可查看。
	目前系统保留关键字有：
		['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
	创建Python文件
		文件名称部分
			1.可以使用英文，不要使用中文
			2.可以使用数字，但是尽量不要全用数字
			3.可以使用_或者-等部分字符分隔文件名
			4.文件命名要有意义方便维护
			5.变量命名要避免和系统使用的保留关键字冲突
		文件后缀部分
			Python不限制文件后缀名，但建议使用更标准的常用格式
			常用文件后缀：   .py    .pyw 
				.pyw 格式是被设计来运行开发完成的纯图形界面程序的		但在开发纯图形界面程序的时候，你也可以暂时把 .pyw 改成 
				.py，方便运行时调出控制台的窗口，查看所有错误信息
		查看文件后缀的方法
		win7   
			打开任意文件夹->组织选项->文件夹和搜索选项->查看选项卡->高级设置->取消"隐藏已知文件类型的扩展名"选项
		win10   
			打开任意文件夹->查看选项卡->倒数第三列中第二个选项(文件扩展名)勾上去	
			
Python语句分类
Python语句分为两类：单行语句 和 代码块/代码组
* 单行语句指的是一行Python代码。
* 代码组指的是特定的语言结构。			

注释
注释就是：注解，解释。主要用于在代码中给代码标识出相关的文字提示(提高代码的可读性) 或 调试程序。
Python中注释分为两类：
	1.单行注释： 单行注释以 # 号开头，在当前行内，# 号后面的内容就是注释内容 
	2.多行注释： 多行注释使用两个 ''' 或两个 """ 将需要注释的内容包裹起来
	
	
运算和运算符
	运算： 由一个以上的值经过变化得到新值得过程，就是运算。
	运算符： 用于运算的符号，就是运算符
	运算的分类：
		1.算数运算
			+   加法运算
			-   减法运算
			*   乘法运算
			/   除法运算
			%   取余运算
			//  取商运算   地板除
			**  幂运算
		2.比较运算/关系运算
			<    小于运算
			>    大于运算
			==   等于运算
			<=   小于等于运算
			>=   大于等于运算
			!=   不等于运算
		3.赋值运算
			=     普通赋值运算
			+=    加法赋值运算
			-=    减法赋值运算
			*=    乘法赋值运算
			/=    除法赋值运算
			%=    取余赋值运算
			//=   取商赋值运算
			**=   幂赋值运算
			所有运算赋值操作的格式都可以转换为[变量 = 变量 运算符 值]
				如：var /= 5   相当于   var = var / 5
		4.逻辑运算
			逻辑运算就是布尔值之间的运算，Python只有三种运算方式
			1.and 逻辑与运算(有假则假；两边为真才是真)
				洗手：
					左手洗了True，右手洗了True，洗完了 True
					左手洗了True，右手没洗False，没洗完 False
					左手没洗False，右手洗了True，没洗完 False
					左手没洗False，右手没洗False，没洗完 False
			2.or 逻辑或运算(有真则真；两边为假才是假)
				钥匙丢了找钥匙：
					你没找到钥匙False，你媳妇也没有找到钥匙False，钥匙没找到 False
					你找到了钥匙True，你媳妇没找到钥匙False，钥匙找到了 True    
					你没有找到钥匙False，你媳妇找到了钥匙True，钥匙找到了 True
					你和你媳妇同时找到了钥匙True和True，钥匙找到了 True
			3.not 逻辑非运算(真变假，假变真)
				老爷们去了泰国
					纯爷们儿True，做了手术，不是纯爷们儿了 False
		5.位运算
			在二进制基础上进行的逻辑运算就是位运算。
			&       按位与运算
			|       按位或运算
			～       按位非运算
			^       按位抑或运算
			<<      左移运算     相当于×2运算
			>>     右移运算  相当于地板除2运算
		6.成员运算
			检测一个数据是否在指定的容器(复合数据)当中
				检测数据1是否在数据2中
					格式：数据1 in 数据2
				检测数据1是否不在数据2中
					格式：数据1 not in 数据2
		7.身份运算
			检测两个变量在内存中是否是同一个值
				检测两个变量在内存中是不是同一个值
					格式：数据1 is 数据2
				检测两个变量在内存中是否不是同一个值
					格式：数据1 is not 数据2
	运算优先级的问题
		运算的优先级
			例如：在数学中，1+5x2，乘法会优先运算。
			我们的Python程序也是一样的，一个运算中存在多个运算符时，系统也有它自己的一套优先级的规则。
			Python的运算优先级规则如下，从上向下按照优先级的由高向低依次排序
			但是我们并不推荐各位死记硬背，因为我们自己写程序遇到优先级问题可以使用()解决，更方便，也更易读。
		**                         指数(最高优先级)
		~ + -                      按位翻转， 一元加号和减号(最后两个的方法名为 +@ 和 -@)
		* / % //                   乘，除，取模和取整除
		+ -                        加法减法
		>> <<                      右移，左移运算符
		&                          位 'AND'
		^ |                        位运算符
		<= < > >=  <> == !=                比较运算符
		= %= /= //= -= += *= **=   赋值运算符
		is is not                  身份运算符
		in not in                  成员运算符
		not or and                 逻辑运算符
	检测数据归属类型
		type()        
			测试时可是使用，开发尽量避免使用
			格式：type(变量)
		isinstance()  
			检测一个数据是否由指定的类型创建
			格式：isinstance(变量，检测的类型)	
		

列表操作
	一组有序数据的组合就是列表
创建列表
	空列表
		方式1：
			变量 = []
		方式2：
			变量 = list()
	具有一个数据的列表
		变量 = [值]      备注：列表中保存的每个都称之为元素
	具有多个数据的列表
		变量 = [值,值,值....]
普通操作
	访问列表中的元素
		变量[索引]
	修改列表中的元素
		变量[索引] = 新值
	添加列表元素
		普通操作无法实现，需要借助函数操作
	删除列表中的元素
		del 变量[索引]
	删除整个列表
		del 列表变量
序列操作
	通用的序列操作包括以下几种： 序列相加、序列相乘、索引、取片/分片、成员检测、最大值、最小值、长度计算
	列表相加操作
		格式：变量 = 列表1 + 列表2
		结果：新的列表
		注意：+两侧都要是列表类型
	列表相乘操作
		格式：变量 = 列表 * 整数
		结果：新的列表
		索引操作
		变量[索引]
	分片操作
		格式：变量 = 列表[:]
			获取整个列表
		格式：变量 = 列表[:结束索引]
			获取列表开头到结束索引之前的数据组成的列表
		格式：变量 = 列表[开始索引:]
			获取列表开始索引到列表末尾的数据组成的列表
		格式：变量 = 列表[开始索引:结束索引]
			获取开始索引和结束索引之间的数据组成的列表（包含开始索引，不包含结束索引）
		格式：变量 = 列表[开始索引:结束索引:间隔值]
			获取开始索引和结束索引之间的数据（按照间隔值来获取）组成的列表（包含开始索引，不包含结束索引）
	成员检测
		检测一个数据是否在列表中
			格式：值 in 列表
			结果：布尔值
		检测一个数据是否不在列表中
			格式：值 not in 列表
			结果：布尔值
序列操作函数
	len()计算列表中元素的个数
	max()获取列表中的最大值
	min()获取列表中的最小值
	list()生成空列表或者将其他数据转化为列表类型
列表的遍历操作
	for...in
		for 变量 in 列表：
			使用变量
	while
		i = 0
		while i<len(列表):
			使用列表中的元素(列表[i])
			i += 1
	遍历同等长度的二级列表
		列表 = [[值1,值2],[值1,值2],....]
		for 变量1,变量2 in 列表:
			使用变量1和变量2
		#注意：变量1取二级列表中的第一个值，变量2取第二个值
	遍历非同等长度的二级列表
		列表 = [[值1，值2]，[值1，值2,值3],[值]...]
		for 变量1 in 列表:
			for 变量2 in 变量1:
				使用变量2(变量2是二级列表中的每个值)
列表内涵/列表推导式 list content
	简单的列表推导式
		格式：[变量 for 变量 in 列表]
		结果：遍历列表中的每个值，将每个值获取之后组成新的列表，可以对获取的值进行修改
		[变量可以其他操作 for 变量 in 列表]
	带有判断条件的列表推导式
		格式：[变量 for 变量 in 列表  if 条件表达式]
		结果：遍历列表中的每个值，根据判断条件决定是否取出指定的值组成新的列表，可以对获取的值进行修改
	多个列表的同时循环的列表推导式
		格式：[变量1+变量2  for 变量1 in 列表1  for 变量2  in 列表2]
		结果：同时遍历列表1和列表2中的每个值，将列表1中的每个值和列表2中的每个值进行运算得到新的列表,新的列表中元素个数=列表1中元素个数 * 列表2中的元素个数
		变量1和变量2可以进行其他操作，不一定非要+ 这只是demo
	带有判断条件的多个列表的同时循环列表推导式
		格式：[变量1+变量2 for 变量1 in 列表1 for 变量2 in 列表2 if 条件表达式]
		结果：同时遍历列表1和列表2中的每个值，根据判断条件将列表1中的值和列表2中的值进行运算，得到新的列表,新的列表数量由判断条件决定
列表专用函数
	append()
		功能：向列表的末尾添加新的元素
		格式：列表.append(值)
		返回值：None
		注意：新添加的值在列表的末尾，该函数直接操作原有列表
	clear()
		功能：清空列表中所有元素
		格式：列表.clear()
		返回值:None
	copy()
		功能：复制列表
		格式：列表.copy()
		返回值：新的列表
	count()
		功能：计算某个元素出现的次数
		格式：列表.count(值)
		返回值：整数
	extend()
		功能：将一个列列表继承另一个列表
		格式：列表.extend(序列)
		返回值：None
		注意：直接改变原有列表
	index()
		功能：获取某个值在列表中的索引
		格式：列表.index(值)
		返回值：整数
		注意：值不存在与列表时抛出异常错误！
	insert()
		功能：在指定位置之前插入元素
		格式：列表.insert(索引,值)
		返回值:None
		注意：直接改变原有列表
	pop()
		功能：在列表中移除一个元素
		格式：列表.pop([索引])
		返回值：无
		注意：没有指定索引，默认移除最后一个元素
	remove()
		功能：移除指定的值
		格式：列表.remove(值)
		返回值：无
		注意：如果有索引的清空下推荐使用POP移除，效率比remove高
	reverse()
		功能：列表反转操作
		格式：列表.reverse()
		返回值：None
	sort()
		功能：列表排序
		格式：列表.sort()                      按照从小到大排序（数字）
		格式：列表.sort(reverse=True)          按照从大到小排序（数字）
		格式：列表.sort(key=函数)               对值进行指定的函数处理之后在从小到大排序
		格式：列表.sort(key=函数，reverse=True)  对值进行指定的函数处理之后在从大到小排序
		返回值：None
		注意：直接改变原有列表
	
	
元组操作
	元组也是一组有序数据的组合，和列表唯一的不同是，元组不可修改
	列表 = 用铅笔写的清单(能擦能改)
	元组 = 用钢笔写的清单(不能擦改)
创建元组
	创建空元组
		方式1：
			变量 = ()
		方式2：
			变量 = tuple()
	创建单个元素的元组
		方式1：
			变量= (值,)
		方式2：
			变量 = 值,
	创建多个元素的元组
		方式1：
			变量 = (值,值...)
		方式2：
			变量 = 值,值...
基本操作
	访问元素
		变量[索引]
		注意： 元组中的元素，只允许访问，无法修改，删除 及 添加。
序列操作
	序列操作：索引，分片，最大值，最小值，长度，加法，乘法...
	元组相加
		变量 = 元组1 + 元组2
		结果：新的元组
	元组相乘
		变量 = 元组 * 整数
		结果：新的元组
	索引操作
		变量[索引]      只能访问不能修改和删除
	分片
		格式：变量[:]                      获取整个元组的元素
		格式：变量[开始索引:]               从开始索引的元组截取末尾
		格式：变量[:结束索引]               从开头截取到结束索引之前
		格式：变量[开始索引:结束索引]         从开始索引位置截取到结束索引之前
		格式：变量[开始索引:结束索引:间隔值]   从开始索引位置按照间隔值截取到结束索引之前
	成员检测
		格式：值 in 元组          作用：检测一个值是否在元组当中
		格式：值 not in 元组      作用：检测一个值是否不再元组当中
序列函数
	len()获取元组的长度
	max()获取元组中的最大值
	min()获取元组中的最小值
	tuple()创建空元组或者将其他序列转化为元组类型
元组的遍历
	for ... in
		变量 = (值1,值2,值3...)
		for 变量 in 元组:
			使用变量获取元组的每个值
	while
		i = 0
		while i<len(元组):
			使用元组变量[i]访问每个值
			i += 1
	遍历长度相同的多级元组
		元组 = ((值1,值2...),(值1,值2...)...)
		for 变量1，变量2.. in 元组:
			使用变量1和变量2
	遍历长度不同的多级元组
		元组 = ((值1,值2...),(值1,值2...)...)
		for 变量1 in 元组:
			for 变量2 in 变量1：
				使用变量2获取每个值
	直接获取二级元组的值
		tuple1[1][3]
元组内涵/元组推导式
	基本格式：
		格式： 变量 = (i for i in 元组)
		结果：不是元组而是一个生成器
	带条件格式：
		格式： 变量 = (i for i in 元组 if 条件表达式)
		结果：不是元组而是一个生成器
	多循环推导式：
		格式： 变量 = (x+y for x in 元组1 for y in 元组2)
		结果：不是元组而是一个生成器   x+y可以是其他操作
	带条件的多循环推导式：
		格式： 变量 = (x+y for x in 元组1 for y in 元组2 if 条件表达式)
		结果：不是元组而是一个生成器   x+y可以是其他操作
元组函数
	index()
		获取指定值在元组中的索引值
		格式：元组.index(值)
		返回值：整数
	count()
		计算某个值在元组中出现的次数
		格式：元组.count(值)
		返回值：整数	
		
		
		
		
字符串操作
	+  字符串连接操作
	*  字符串复制操作
	[] 字符串索引操作，通过索引访问指定位置的字符，索引从0开始
	[::] 字符串取片操作
		完整格式：[开始索引:结束索引:间隔值]
		[:结束索引]  从开头截取到结束索引之前
		[开始索引:]  从开始索引截取到字符串的最后
		[开始索引：结束索引]  从开始索引截取到结束索引之前
		[:]  截取所有字符串
		[开始索引:结束索引:间隔值]  从开始索引截取到结束索引之前按照指定的间隔截取字符
	r'字符串'   元字符串，所有字符串中的转义字符不会转义，当作普通字符
字符串函数
	capitalize()
		功能：首字母大写
		格式：字符串.capitalize()
		返回值：新字符串
	title()
		功能：将每个单词首字母变为大写
		格式：字符串.title()
		返回值：新字符串
	upper()
		功能：将所有字母变为大写
		格式：字符串.upper()
		返回值：新字符串
	lower()
		功能：将所有字母变为小写
		格式：字符串.lower()
		返回值：新字符串
	swapcase()
		功能：大小写互换
		格式：字符串.swapcase()
		返回值:新字符串
	len()
		功能：计算字符串的长度
		格式:len(字符串)
		返回值：整型
	count()
		功能：计算指定字符串出现的次数
		格式：字符串.count(查找字符串[,开始索引[,结束索引]])
		返回值：整数
	find()
		功能：查找指定字符串第一次出现的位置
		格式：字符串.find(查找字符串[,开始索引[,结束索引]])
		返回值：整数   找不到返回-1
	index()
		功能：查找指定字符串第一次出现的位置
		格式：字符串.index(查找字符串[,开始索引[,结束索引]])
		返回值：整数   找不到抛出错误！
		注意： find 和 index 的区别在于，当指定字符查找不到时，find返回-1，程序可以继续执行，而index则报错，程序无法继续执行。
	startswith()
		功能：检测字符串是否以指定的字符串开头
		格式：字符串.startswith(查找字符串)
		返回值：布尔值
	endswith()
		功能：检测字符串是否以指定的字符串结尾
		格式：字符串.endswith(查找字符串)
		返回值：布尔值
	isupper()
		功能：检测一个字符串中的英文是否都是大写字母，符号不算
		格式：字符串.isupper()
		返回值:布尔值
	islower()
		功能：检测一个字符串中的英文是否都是小写字母，符号不算
		格式：字符串.islower()
		返回值：布尔值
	isalnum()
		功能：检测字符串是否由数字，字母和文字等组成
		格式：字符串.isalnum()
		返回值：布尔值  汉字当作普通字符处理，没有标点和特殊字符就是真，空字符串为false
	isalpha()
		功能：检测字符串是否有字母和文字组成
		格式：字符串.isalpha()
		返回值：布尔值，汉字当作普通字母处理。空字符串为false
	isdigit()
		功能：检测字符串是否由纯数字组成  十进制
		格式：字符串.isdigit()
		返回值：布尔值
	isnumeric()
		功能：检测字符串是否是数值字符串  数字整数
		格式:字符串.isnumeric()
		返回值：布尔值
	isdecimal()
		功能：检测字符串是否是纯数值字符串组成
		格式:字符串.isdecimal()
		返回值：布尔值
	isspace()
		功能：检测字符串是否由空白字符组成
		格式:字符串.isspace()
		返回值：布尔值
	istitle()
		功能：检测字符串是否符合title()的结果
		格式：字符串.istitle()
		返回值:布尔值
	split()
		功能：将字符串按照指定字符进行切割操作
		格式：字符串.split(切割指定字符串)
		返回值：列表
	splitlines()
		功能：将字符串按照换行位置进行切割操作
		格式：字符串.splitlines([结束符号])
		返回值：列表
	join()
		功能：将列表中的内容按照指定字符连接成一个字符串
		格式:连接字符串.join(列表)
		返回值：字符串
	zfill()
		功能：在原有字符串长度不足指定长度时，用0填充
		格式:字符串.zfill(指定长度)
		返回值：字符串   不足的长度使用0填满，原来的字符串内容靠右
	center()
		功能：指定字符串长度，并且使得元字符串内容居中，其余位置使用指定字符填充
		格式: 字符串.center(指定长度[，填充字符])
		返回值：字符串  填充字符默认空格，可以指定其他
	ljust()
		功能：指定字符串长度，并且使得元字符串内容靠左，其余位置使用指定字符填充
		格式：字符串.ljust(指定长度[，填充字符])
		返回值：字符串  填充字符默认空格，可以指定其他
	rjust()
		功能：指定字符串长度，并且使得元字符串内容靠右，其余位置使用指定字符填充
		格式：字符串.rjust(指定长度[，填充字符])
		返回值：字符串  填充字符默认空格，可以指定其他
	strip()
		功能：去掉左右2侧的指定字符，默认空格
		格式:字符串.strip([指定字符])
		返回值：字符串
	lstrip()
		功能：去掉左侧的指定字符，默认空格
		格式:字符串.lstrip([指定字符])
		返回值：字符串
	rstrip()
		功能：去掉右侧的指定字符，默认空格
		格式:字符串.rstrip([指定字符])
		返回值：字符串
	maketrans() 和 translate()
		maketrans()
			功能：制作用于字符串替换的映射表
			格式: 字符串.maketrans('查找字符','替换字符')    两个字符必须长度相等
			返回值：字典
		translate()
			功能：进行字符串替换操作
			格式：字符串.translate(映射表)
			返回值：替换之后的字符串		
	
	
	
	
	
	
字典操作
	以键值对方式存在的无序数据的组合就是字典
创建字典
	创建空字典
		方式1：
			变量 = {}
		方式2：
			变量 = dict()
	创建多个元素的字典
		方式1：
			变量 = {键:值,键:值....}
		方式2：
			变量 = dict({键:值,键:值....})
		方式3：
			变量 = dict(键=值,键=值...)
			注意：该方式键作为形参名使用，不可以添加引号，必须符合变量规则
		方式4：
			变量 = dict([(键,值),(键,值)...])
			变量 = dict([[键,值],[键,值]...])
			变量 = dict(((键,值),(键,值)...))
		方式5：
			变量 = dict(zip((键，键...),(值,值...)))
字典的基本操作
	访问字典元素
		变量[键]
	添加字典元素
		变量[新键] = 值
	修改字典元素
		变量[键] = 新值
	删除字典元素
		del 变量[键]
字典的序列操作
	成员检测
		格式：值 in 字典
			检测一个值是否在字典的键中
		格式：值 not in 字典
			检测一个值是否不再字典的键中
序列函数
	len()计算字典中元素的长度
	max()获取字典中最大的键
	min()获取字典中最大的值
	dict()创建空字典或者将其他类型转化字典
字典的遍历
	遍历键
		for 变量i in 字典:
			#使用i遍历所有的键，有键就可以通过变量访问其值
	遍历键和值
		for 变量i，变量j in 字典.items():
			#使用变量i遍历所有键，通过变量j遍历所有值
字典内涵/字典推导式
	普通的字典内涵
		变量= {key:value for key,value in 字典.items()}
	带有判断条件的字典内涵
		变量= {key:value for key,value in 字典.items() if 条件表达式}
	多个循环的字典内涵
		变量 = {i+x:j+y for i，j in 字典1.items for x，y in 字典2.items()}
	带有判断条件的多个循环的字典内涵
		变量 = {i+x:j+y for i，j in 字典1.items for x，y in 字典2.items() if 条件表达式}
字典专用函数
	clear()
		功能：清空字典
		格式：字典.clear()
		返回值：None
		注意：直接改变原有字典
	copy()
		功能：复制字典
		格式：字典.copy()
		返回值：新的字典
	fromkeys()
		功能：使用指定的序列作为键创建字典
		格式：字典.fromkeys(序列,值)
		返回值：字典
	get()
		功能：根据键获取指定的值
		格式：字典.get(键[，默认值])
		返回值:值
		注意:如果键不存在，则使用默认值,如果没有默认值则返回None
	items()
		功能：将字典的键值转化成类似元组的形式方便遍历
		格式：字典.items()
		返回值：类似元组的类型
	keys()
		功能：将字典的所有键组成一个序列
		格式：字典.keys()
		返回值:序列
	values()
		功能：将字典的所有值组成一个序列
		格式：字典.values()
		返回值：序列
	pop()
		功能：移除字典中指定的元素
		格式：字典.pop(键[,默认值])
		返回值：被移除的键对应的值
		注意：如果键不存在，则报错，如果键不存在，默认值设置，则返回默认值
	popitem()
		功能：移除字典中的键值对
		格式：字典.popitem()
		返回值：键值对组成的元组
		注意：弹一个原字典就少一个，字典为空就不可以弹出，会报错
	setdefault()
		功能：添加一个元素
		格式：字典.setdefault(键,值)
		返回值:None
		注意：添加是键存在则不进行任何操作，键不存在则添加，添加是不写值，默认None值
	update()
		功能：修改字典中的值
		方式1：
			格式： 字典.update(键=值)
			返回值：None
			注意:此处的键作为关键字参数使用，不可以添加''
		方式2：
			格式: 字典.update({键:值})
			返回值：None	
		
	
顺序结构和分支结构	
	流程控制
		流程： 计算机执行代码的顺序，就是流程。
		流程控制： 对计算机代码执行顺序的控制，就是流程控制。
		流程分类： 流程控制一共分为三类，分别是 顺序结构、分支(选择)结构、循环结构。
	顺序结构
		顺序结构就是代码一种自上而下执行的结构，这是Python默认的流程。
	分支(选择)结构
		分支结构一共分为4类，分别是 单项分支、双项分支、多项分支、巢状分支
		单项分支
			格式：
				if 1 < 5:
				print('条件为真输出我')
			特征：
				1.if条件表达式结果为真，则执行if之后所控制的代码组，如果为假，则不执行后面的代码组
				2.冒号:之后下一行的内容必须缩进，否则语法错误
				3.if之后的代码中如果缩进不一致，则可能缩进不一致的代码不会受到if条件表达式的控制
				4.冒号:后面的代码是在条件表达式结果为真的情况下执行，所以称之为真区间 或 if区间
		双项分支
			格式：
				if 1 < 5:
					print('条件为真输出我')
				else:
					print('条件为假输出我')
			特征：
				1.双项分支有两个区间，分别是 True控制的if区间 和 False控制的else区间
				2.if区间的内容在双项分支中必须缩进，否则语法错误
		多项分支
			格式：
				if 1 > 5:
					print('如果1 > 5，我会被输出')
				elif 9 < 8:
					print('如果9 < 8，我会被输出')
				else:
					print('如果以上两条都不成立，我会被输出')
			特征：
				1.多项分支可以添加无限个elif分支，无论如何，只会执行众多分支的其中一个
				2.执行完一个分支后，分支结构就会结束，后面的分支都不会判断，也不会执行
				3.多项分支的判断顺序是自上而下逐个分支进行判断的。
		巢状分支
			格式:
				if 1 < 5:
					print('1真的小于5哦')
					if 3 < 9:
						print('如果3 < 9，我会被输出')
				else:
					print('如果上面条件不成立，我会被输出')
			特征：
				巢状分支是其他他分支结构的嵌套结构，无论哪个分支都可以嵌套	
	
	
	
循环结构
	循环结构可以减少源程序重复书写的工作量(代码量)，用来描述重复执行某段算法的问题，这是程序设计中最能发挥计算机特长的程序结构。
Python中循环结构分为两类，分别是 while 和 for .. in
while
	格式1：
		num1,num2 = 3,5
		while num1 < num2:
			print('如果条件成立，会进入循环体，我所处的这块区域，就是循环体')
			num1 += 1   #控制循环条件中的变量，否则进入死循环
		死循环： 死循环就是循环不会终止的循环类型，设置条件永远为True来实现，但非常占用资源
	格式2：
		num1,num2 = 3,5
		while num1 < num2:
			print('如果条件成立，会进入循环体')
			num1 += 1
		else:
			print('条件不成立时，我会被输出')
		注意： while循环中的else是在while条件表达式为假的情况下执行的代码内容
for ... in
	for 变量 in 容器：用于遍历容器类的数据(字符串，列表，元组，字典，集合)
	格式1：
		user_list = ['小明','小红','小强','小军']
		for val in user_list:
			print(val)
	格式2：
		data = ('a','alibaba'),('b','baidu'),('c','changhong')
		for k,v in data:
			print(k,'======>',v)
		使用格式2请注意： 要求遍历的容器必须是以下几种格式
			[(),(),()]    列表中有元组
			[[],[],[]]    列表中有列表
			((),(),())    元组中有元组
			{(),(),()}    集合中有元组
			字典的特殊使用
	格式3：
		data = ('a','b','c','d','e')
		for v in data:
			print(v)
		else:
			print('我else区间又来啦！')
		循环结束时执行else区间的代码
流程控制语句
	break
		翻译：破坏，结束
		作用：在循环中break的作用是终止当前循环结构的后续所有操作，一点程序运行了break，循环也就终止了。
	continue
		翻译：继续
		作用：在循环中continue的作用是跳过本次循环，开始下一次循环。continue执行之后本次循环的后续代码不再执行，直接进入下一次循环。
	pass
		翻译：忽略
		作用：pass是没有任何意义的空语句，主要用来占位用，避免语法错误。	
	
	
	
函数概念
	在计算机中称之为函数，在现实生活中称之为功能。 
	函数是能够实现特定功能的计算机代码，它是一种特定的代码组结构。
函数的作用
	1.提高代码的重复利用率，避免重复开发相同代码
	2.提高程序的开发效率
	3.便于程序维护
函数名的命名规则，和变量基本一样：
	1.推荐使用英文，禁止使用中文
	2.可以使用数字，但不能以数字开头
	3.不可以使用特殊字符，除了下划线_
	4.函数名严格区分大小写
	5.函数名必须要有意义
	6.不能和系统保留关键字冲突
函数的定义
	1.基本格式：
		def 函数名():
			pass
		示例：
			#定义函数
			def funName():
				pass #此处编写功能代码
			funName() #调用
		注释：
			函数的特征：函数定义之后，不会自动执行，只会在调用的时候执行。不调用，不执行。
	2.带有参数的格式：
		def 函数名(参数1，参数2...):
			pass
		示例：
			#定义带有参数的函数
			def funName(arg):
				print('接收到的参数：',arg)
			funName(666) #调用
		注释：
			形参：形式上的参数，声明函数时，括号()中的参数，是形参。
			实参：实际上的参数，调用函数是，括号()中的参数，是实参。
			实参将值传递给形参的本质过程，本质上就是简单的变量赋值。
	3.带有默认值的参数的格式：
		def 函数名(参数1 = 值1,参数2 = 值2...):
			pass
		示例：
			#定义带有默认值参数的函数
			def funName(arg = 'jack'):
				print('参数值：',arg)
			funName() #调用方式一
			funName('mark') #调用方式二  调用时传的参数会覆盖默认值
		注释：
			如果形参有默认值，调用时可以不需要传参，系统会直接使用参数的默认值。
			调用时给有默认值的参数传参，实参会覆盖形参的默认值。本质上就是变量的重新赋值。
	4.使用关键字参数格式：
		函数名(形参1 = 实参1,形参2 = 实参2...)
		示例：
			#定义带有默认值参数的函数
			def funName(name = 'jack',age = 18,sex = 'man'):
			print('name:',name)
			print('age:',age)
			print('sex:',sex)
			funName(8,'二狗','Superman') #参数较多时赋值顺序颠倒，将会影响程序执行结果
			funName(age = 8,name = '二狗',sex = 'Superman') #关键字参数赋值完美解决上面的问题
		注释：
			关键字参数就是调用函数时，在实参前面指定形参的做法，为了防止参数按照位置传递出现的错误。
	5.收集参数使用方法：
		收集参数可以收集的参数不受数量限制
		1）非关键字收集参数
			def 函数名(*参数名):
				pass
			示例：
				#定义带有非关键字收集参数的函数
				def funName(*arg):
					for v in arg: #遍历
						print(v)
				funName(1,2,3,'a','b','c') #调用
			注释：
				1.非关键字收集参数，在形参前添加一个*即可
				2.非关键字收集参数，收集的实参会组成一个元组
				3.非关键字收集参数，接受没有任何形参接受的非关键字实参
				4.非关键字收集参数，可以和普通的形参共存
		2) 关键字收集参数
			def 函数名(**参数名):
				pass
			示例：
					#定义带有关键字收集参数的函数
					def funName(**car):
						for v in car: #遍历
							print(v,'value : ',car[v])
					funName(a = '卡车',b = '火车',c = '公交车') #调用
			注释：
				1.关键字收集参数，在形参前添加两个*
				2.关键字收集参数，收集的实参会组成一个字典，形参名作为键，值作为值
				3.关键字收集参数，仅接收没有任何形参接收的关键字参数
				4.关键字收集参数，可以和普通的形参共存
			多种参数混合使用应当注意的 定义函数时尽量避免多种参数格式混合(普通参数，关键字参数，两种收集参数) 
				1.普通参数和关键字参数必须在两种收集参数之前 
				2.非关键字收集参数，必须在关键字收集参数之前 
				3.如果多种参数混合在一起用，必须注意禁止参数多次赋值操作(普通参数赋值在前，关键字参数赋值在后)
函数的返回值
	根据执行函数完毕是否可以得到一个结果，我们可以将函数分为两种类型。
		执行过程函数：
			函数执行完毕之后，接收不到任何返回结果的函数。如：print()
		具有返回值得函数：
			函数执行完毕之后，会产生一个结果，可以被接收和使用的函数。如：type()
	格式：
		def 函数名(参数...):
			Python code...
			return 返回值 #有return的函数，就是有返回值的函数
		变量名 = 函数名(参数...)  #我们可以通过一个变量去接收函数的返回值
	注释：
		1.具有return语句的函数，我们称之为具有返回值的函数
		2.return可以为当前函数执行完毕的函数返回一个结果，这个返回值可以用变量接收
		3.return执行之后，函数将会终止，所以return之后的语句是不会被执行的
		4.一个函数可以使用多个return语句，但是只有一个会被执行，一般都是放入分支结构中
		5.一个函数如果需要返回多个数据，使用复合数据类型(list,tuple,set,dict)来操作即可
递归函数
	在函数内调用当前函数本身的函数就是递归函数
	定义递归函数
		#定义一个递归函数
		def tubie(num):
			#1.输出num
			print(num)
			#2.判断条件，不改变num
			if num >0:
				tubie(num-1)
			else:
				print('================')
			#3.输出num
			print(num)
	#调用递归函数
		tubie(3)	
	
	
	
	
	
	
	
面向对象 Object Oriented
	面向对象的学习：
		面向对象的语法（简单，记忆就可以搞定）
		面向对象的思想（稍难，需要一定的理解）
面向过程和面向对象的区别
	面向过程开发，以函数作为基本结构使用：
		吃饭      -> 吃饭的函数
		喝水      -> 喝水函数
		洗衣服    -> 洗衣服的函数
		睡觉      -> 使用充气娃娃的函数
		看电影    -> 买票开电影函数
	面向对象的开发，以对象作为基本结构使用： 女朋友{ 喂饭功能 喂水功能 洗衣服功能 陪你睡觉功能 陪你看电影功能 .... }
		吃饭->调用女盆友的喂饭功能
		喝水->调用女朋友的喂水功能
		洗衣服->调用女朋友的洗衣服功能
		睡觉->调用女朋友的陪睡功能
	面向对象的开发非常适合大型程序开发，开发速度和后期维护都比过程化开发要好很多。同时，也会降低一点效率。
	语言中对象结构的特色：高内聚，低耦合。
面向对象相关的单词：
	OO  面向对象
	OOP 面向对象的程序开发
	OOA 面向对象的分析
	OOD 面向对象的设计
	OOI 面向对象的实现
	OOA -> OOD -> OOI 面向对象的实现过程
类和对象
	什么是类
		人类就是一个类
		动物类也是一个类
		鸟类就是一个类
		女朋友也是一个类
		基友也是一个类
		瓶子都是一个类
		类是一个实物的特征的集合，是抽象的概念。
		打蛋蛋是一个类
		XXOO也是一个类
		撩妹也是一个类
		开车也是一个类
		打人也是一个类
		类也是行为和操作的概念的集合。也是不具体的操作，没有真正操作过。
		类是抽象的概念，仅此而已！
	什么是对象
		霍云瑞这个人他是一个对象
		霍云瑞家的那个小鸡鸡是一个对象
		霍云瑞的第一个女朋友就是一个对象
		霍云瑞的当前的基友就是一个对象    
		这个瓶子就是一个对像。
		教室后面那个空调就是一个对象。
		对象就是具体存在的看得见摸得着的某个实物。
		昨天霍云瑞打一次自己的蛋蛋，就是一个对象
		今天中午霍云瑞吧马浚龙XXOO了就是一个对象
		今天上午霍云瑞吧马俊龙撩了就是一个对象
		马俊龙今天晚上把霍云瑞打了，这就是一个对象
		真实发生过得行为就是对象
		对象一定是具体的或者发生过的事物！
类和对象的关系
	类是多个对象归纳总结而来的，是一种概念，包含所有对象。
		由对象总结出类的过程，叫做抽象化
	对象是类的具体实现或者实施而来，他是真实的，特指某个事物
		由类制作出对象的过程，叫做实例化
如何书写类文件
	推荐使用驼峰命名法来书写文件：
	驼峰命名法：
		类名：每个单词的首字母大写
			人类  Person
			开车  DriveCar
			撩妹  LiaoMei
		函数名/变量：除了第一个单词之外首字母大写
			泷泽萝拉  longZeLuoLa
			约炮函数  yuePao  或者yue_pao（不是驼峰命名）
	一个文件如果是一个单独的类，那么直接使用类名来当作文件名即可
类的组成
	类中只有2种内容：成员属性和成员方法
	成员属性:
		用于描述类的特征的变量就是成员属性
	成员方法：
		用于描述类的功能的函数就是成员方法
类的书写规则
	1.必须使用class关键字来声明一个类
	2.类的名称需要符合驼峰命名法（规范）
	3.类中只能存在2种内容，成员属性和成员方法，除此之外，所有的代码都禁止出现！
	4.声明成员属性时，所有成员属性必须有值，如果没值会报错！，推荐使用None等值代替
	5.成员方法只需要按照函数的规则声明即可
实例化对象
	实例化对象格式
		对象变量 = 类()
	类的类型为 type
		<class 'type'>
	类的值就是类本身
		<class '__main__.Person'>
	对象的类型为类
		<class '__main__.Person'>
	对象的值，对象本身
		<__main__.Person object at 0x020DC650>
检测类和对象的成员
	检测类成员
		类名.__dict__
	检测对象成员
		对象.__dict__
类和对象成员的操作
	类成员操作
		访问类中成员
			类名.成员属性名
			类名.成员方法名()      （没有参数要求，所有方法都可以通过类访问）
		修改类中成员
			类名.成员属性名 = 值
			类名.成员方法名 = 新值  （如果需要函数只能用lambda）
		删除类中成员
			del 类名.成员属性名
			del 类名.成员方法名
		添加类中成员
			类名.新成员属性名 = 值
			类名.新成员方法名 = 值  （如果需要函数只能用lambda）
	对象成员操作
		访问对象中成员
			对象变量.成员属性名
			对象变量.成员方法名()  （必须有一个用于接收对象本身的形参）
		修改对象中成员
			对象变量.成员属性名 = 值
			对象变量.成员方法名 = 新值  （如果需要函数只能用lambda）
		删除对象中成员
			del 对象变量.成员属性名
			del 对象变量名.成员方法名
		添加对象中成员
			对象变量.新成员属性名 = 值
			对象变量.新成员方法名 = 值 （如果需要函数只能用lambda）
关于self
	他不是关键字，是一个随意书写的字符串而已
	1.英文单词的意义 ：自己
	2.绑定类的方法，只能通过类来访问的方法，就是绑定类的方法
	3.非绑定类的方法，就是可以通过对象访问的方法就是非绑定的方法
	4.绑定类与非绑定类的方法不取决于语法，而取决于设计者如何设计该方法
	5.一般情况下非绑定类的方法第一个参数写单词self，但是这不是唯一的单词，写什么都行，self不是关键字，不是关键字，不是关键字！
面向对象的三大特性
	面向对象都具有三大特性：封装，继承 和 多态
	封装特性
		封装就是对类和对象的成员访问进行限制，设定可以访问的方式和不可以访问的方式。
		封装的三个级别：
			私有化封装      -> private  英文单词而已不是关键字
			受保护的封装     -> protected  英文单词而已不是关键字
			公共的封装      -> public 英文单词而不是关键字
		检测封装的三个位置：
			类中/对象中
			类外部/对象外部
			子类中
		私有化封装 private
			私有化封装是最高级别的封装。私有化封装之后的成员,只能在类中/对象中访问，类的外部，子类中都不可以访问到。
			私有化封装：在成员名称前添加2个_即可
			例如：封装heart -> __heart  
			python将heart 改名为 _类名__成员名  
			封装后的访问限制：
				类中/对象中      可以访问
				类外/对象外      不可以访问
				子类/子类对象     不可以访问
			注意：在python中实现的封装操作，不是通过权限限制而是通过改名(name mangling 改名策略)实现的，名字变了找不到而已。
			可以通过 对象.类名 __方法或类名.类名 __方法名访问到（但禁止这么干）
		受保护的封装 protected
			受保护的封装是一定级别的封装，封装之后，只有部分位置可以访问（类和子类），部分位置（类外）不可以访问。
			受保护的封装： 在成员名称前添加1个_即可
			例如:受保护 money -> _money
			封装后的访问限制：
				类中/对象中      可以访问
				类外/对象外      可以访问（原则上类外不行，但是没实现）
				子类/子类对象     可以访问
		公共的封装 public
			所有的成员默认都是公共的封装级别，可以在类中，类外，及子类中正常访问
			类中/对象中            可以访问
			类外/对象外            可以访问
			子类/子类对象            可以访问
	继承
		继承就是可以获取另外一个类中的成员属性和成员方法。(并非所有成员)
		作用：
			继承的作用是增加代码的复用性，节省不必要的重复代码，提高开发效率，同时可以设置类之间的关系。
	继承的两个概念：
		父类
			用于被继承的类，称之为父类，也叫做基类，或者超类
		子类
			继承其他类的类，称之为子类，也叫做派生类
	继承的格式
		class 父类：
			pass
		class 子类(父类)：#继承操作的关键步骤
			pass
	继承的特征
		1.所有类都是继承自object类（object类对应的对象就是object对象，也是万物皆对象）
		2.子类继承父类则可以访问父类的所有成员。（私有成员除外）
		3.子类继承父类并不会将父类的所有成员复制到子类当中去，访问父类成员是间接通过父类来访问的，
		4.子类可以具有自己独有的属性和方法
		5.子类可以重载父类中的方法，只需要设置和父类指定成员相同的名称即可实现重载，重载之后的成员，子类只会访问当前类中的成员，而不会调用父类中同名的成员
		6.子类中如果重载父类的方法，并且还想将重载的父类方法借调过来使用，可以在重载的方法中使用如下方法
			[父类名.方法()](适合类)  或者  [super().方法()](适合对象)
	单继承和多继承
		单继承：每个类只能继承一个类的方式称为单继承。
		多继承：每个类可以同时继承多个类的方式称为多继承。
		python属于多继承语言！但是一般不用
	多继承格式：
		class 父类1:
			pass
		class 父类2:
			pass
		class 子类(父类1,父类2)：
			pass
		多继承之后，子类就具备了所有父类的成员（私有成员除外）
		多个父类具有相同的成员时，子类继承[继承列表]中第一个类的方法
	菱形继承/钻石继承
		菱形继承格式
		class A:
			pass
		class B(A):
			pass
		class C(A):
			pass
		class D(B,C):
			pass
			A
		   / \
		  B   C
		   \ /
			D
		菱形继承存在的问题
			如果BC类同时继承了A类，D类又继承了BC两个类的情况下(菱形继承)，
			在调用BC中某个同名方法(该方法都继承自A类)时会导致继承自A类的该方法被多次调用。产生逻辑问题！
			所以python使用 super() 类来解决了多继承的菱形继承问题
	MRO列表
		Method Realtion Order 用来制作一个继承关系的列表
		python3中使用C3算法来计算MRO列表（计算过程暂时忽略）
		MRO列表的制作原则：
			1.子类永远在父类的前面
			2.如果继承了多个父类，那么按照()中的顺序在列表中摆放
	super()
		super不是一个关键字,也是不是有函数,他是一个类
		super()的作用不是查找父类，而是找MRO列表的上一个类
		super()和父类没有任何实质性的关系，只是有时候能调用到父类而已。
		在单继承的情况下，super()永远调用的是父类/父对象
		格式：
			super().方法()      #python3的格式
		多继承按需操作，在没有必要的时候避免强行使用!
	mixin 设计模式
		该设计模式的主要作用是采用多继承方式，进行类的扩展。
		优点：
			1.mixin可以在对类不做任何修改的情况下，扩展类的功能（添加父类）
			2.可以方便的组织和维护各种不同组件的划分。
			3.可以根据需要任意调整
			4.可以避免创建更多的类，也可以避免继承导致的混乱
		示例：
			#水果类
			class Fruit:
				pass
			#礼物类和非礼物类
			class Gift:
				pass
			class NotGift:
				pass
			#南方北方类
			class South:
				pass
			class North:
				pass
			#爽和不爽的苹果
			class Cool:
				pass
			class NotCool:
				pass
			#真实水果类
			class Apple(Fruit,Gift,North,NotCool):
				pass
			class Pear(Fruit,NotGift,North,NotCool):
				pass
			class Banana(Fruit,NotGift,North,Cool):
				pass
			class Orange(Fruit,Gift,South,NotCool)	












